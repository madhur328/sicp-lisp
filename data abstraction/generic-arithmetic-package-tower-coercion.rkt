#lang racket

(define *op-table* (make-hash))

(define (put op type item)
  (hash-set! *op-table* (list op type) item))

(define (get op type)
  (hash-ref *op-table* (list op type) #f))
  
(define (attach-tag tag x)
  (if (eq? tag 'integer)
      x
      (cons tag x)))

(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) 'integer)
        (else (error "Bad tagged datum -- TYPE-TAG" datum))))  

(define (contents datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (else (error "Bad tagged datum -- CONTENTS" datum))))               

(define (install-integer-package)
  (define (make-integer x) x)
  (define (add x y)
    (+ x y))
  (define (sub x y)
    (- x y))
  (define (mul x y)
    (* x y))
  (define (div x y)
    (/ x y))
  (define (tag x) (attach-tag 'integer x))
  (define (raise x)
    (make-rational x 1))
  (put 'raise '(integer) raise)
  (put 'add '(integer integer)
       (lambda (x y) (tag (add x y))))
  (put 'sub '(integer integer)
       (lambda (x y) (tag (sub x y))))
  (put 'mul '(integer integer)
       (lambda (x y) (tag (mul x y))))
  (put 'div '(integer integer)
       (lambda (x y) (tag (div x y))))
  (put 'make 'integer
       (lambda (x) (tag (make-integer x))))
  (put 'equ? '(integer integer)
        (lambda (x y) (= x y)))
  (put '=zero? '(integer)
       (lambda (arg) (= arg 0)))
  'done)

(define (make-integer x)
  ((get 'make 'integer) x))

(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))

(define (install-rational-package)
  (define (numer x) ( car x))
  (define (denom x) ( cdr x))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  (define (add x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))                            
  (define (tag x) (attach-tag 'rational x))
  (define (project rat)
    (make-integer (round (/ (numer rat) (denom rat)))))
  (define (raise rat)
    (make-real (* 1.0 (/ (numer rat) (denom rat)))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add x y))))       
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub x y))))       
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul x y))))       
  (put 'div '(rational rational)
       (lambda (x y) (tag (div x y))))       
  (put 'raise '(rational) raise)
  (put 'project '(rational) project)
  (put 'equ? '(rational rational)
      (lambda (n1 n2) (= (* (numer n1) (denom n2))
                        (* (numer n2) (denom n1)))))
  (put '=zero? '(rational)
        (lambda (arg) (= (numer arg) 0.0)))                                     
  'done)  

(define (make-rational n d)
  ((get 'make 'rational) n d))

(define (install-real-package)
  (define (make-real x) x)
  (define (tag x) (attach-tag 'real x))
  (define (raise x)
    (make-complex-from-real-imag x 0))
  (define (project real)
    (let ((rat (rationalize (inexact->exact real) 1/100)))
      (make-rational (numerator rat) (denominator rat))))
  (put 'make 'real
       (lambda (x) (tag (make-real x))))
  (put 'raise '(real) raise)
  (put 'project '(real) project)
  (put 'add '(real real)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(real real)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(real real)
       (lambda (x y) (tag (* x y))))
  (put 'div '(real real)
       (lambda (x y) (tag (/ x y))))
  (put 'equ? '(real real)
        (lambda (x y) (= x y)))
  (put '=zero? '(real)
       (lambda (arg) (= arg 0.0)))        
  'done)

(define (make-real x)
  ((get 'make 'real) x))

(define (square x) (mul x x))
(define (sqrt x) (apply-generic 'sqrt x))
(define (atan-gen y x) (apply-generic 'atan y x))
(define (sin-gen x) (apply-generic 'sin x))
(define (cos-gen x) (apply-generic 'cos x))

; to make complex numbers have magnitude, angle, real-parts, imaginary parts as other numbers,
; we make operations square, sqrt, atan, sin, cos generic and install them for all other numbers
; we make the selectors, constructors, predicates (like equ?) and ops (add mul..etc) use these generic operations 
(define (install-generic-complex-op-package)
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (put 'sqrt '(integer)
       (lambda (x) (drop (attach-tag 'real (expt x 0.5)))))
  (put 'sqrt '(rational)
       (lambda (x) (drop (attach-tag 'real (expt (* 1.0 (/ (numer x) (denom x))) 0.5)))))
  (put 'sqrt '(real)
       (lambda (x) (drop (attach-tag 'real (expt x 0.5)))))
  (put 'atan '(integer integer)
       (lambda (y x) (drop (attach-tag 'real (atan y x)))))              
  (put 'atan '(rational rational)
       (lambda (y x) (drop (attach-tag 'real (atan (* 1.0 (/ (numer y) (denom y))) 
                                                   (* 1.0 (/ (numer x) (denom x))))))))
  (put 'atan '(real real)
       (lambda (y x) (drop (attach-tag 'real (atan y x)))))
  (put 'sin '(integer)
       (lambda (x) (drop (attach-tag 'real (sin x)))))                                                                 
  (put 'sin '(rational)
       (lambda (x) (drop (attach-tag 'real (sin (* 1.0 (/ (numer x) (denom x))))))))
  (put 'sin '(real)
       (lambda (x) (drop (attach-tag 'real (sin x)))))                                                                        
  (put 'cos '(integer)
       (lambda (x) (drop (attach-tag 'real (cos x)))))                                                                 
  (put 'cos '(rational)
       (lambda (x) (drop (attach-tag 'real (cos (* 1.0 (/ (numer x) (denom x))))))))
  (put 'cos '(real)
       (lambda (x) (drop (attach-tag 'real (cos x)))))                                                                        
  'done)

(define (install-rectangular-package)
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (add (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan-gen (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a)
    (cons (mul r (cos-gen a)) (mul r (sin-gen a))))
    (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)  

(define (install-polar-package)
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (mul (magnitude z) (cos-gen (angle z))))
  (define (imag-part z)
    (mul (magnitude z) (sin-gen (angle z))))
  (define (make-from-real-imag x y)
    (cons (sqrt (add (square x) (square y)))
          (atan-gen y x)))
    (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar
       (lambda (r a) (tag (make-from-mag-ang r a))))          
  'done)

(define (real-part z) (apply-generic 'real-part z))
(define (imag-part z) (apply-generic 'imag-part z))            
(define (magnitude z) (apply-generic 'magnitude z))
(define (angle z) (apply-generic 'angle z))    

(define (install-complex-package)
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))
  (define (project complex)
    (make-real (real-part complex)))
  (define (add-complex z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2))
                         (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (sub (real-part z1) (real-part z2))
                         (sub (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (mul (magnitude z1) (magnitude z2))
                       (add (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (div (magnitude z1) (magnitude z2))
                       (sub (angle z1) (angle z2))))                                                                         
  (define (tag x) (attach-tag 'complex x))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))                     
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'add '(complex complex)
       (lambda (x y) (tag (add-complex x y))))       
  (put 'sub '(complex complex)
       (lambda (x y) (tag (sub-complex x y))))       
  (put 'mul '(complex complex)
       (lambda (x y) (tag (mul-complex x y))))       
  (put 'div '(complex complex)
       (lambda (x y) (tag (div-complex x y))))       
  (put 'project '(complex) project)
  (put 'equ? '(complex complex)
      (lambda (z1 z2) (and (equ? (real-part z1) (real-part z2))
                          (equ? (imag-part z1) (imag-part z2)))))
  (put '=zero? '(complex)
       (lambda (arg) (= (magnitude arg) 0.0)))                          
  'done)

(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))

(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

(define (compose f g)
  (lambda (x) (f (g x))))

(define (repeated f n)
  (define (recursive n)
    (if (= n 0) 
        (lambda (x) x)
        (compose f (recursive (- n 1)))))
  (recursive n))

; when new levels are added are added to the tower, we need to modify tower variable to include new levels aswell
(define tower '(integer rational real complex))

(define (add x y) (drop (apply-generic 'add x y)))

(define (sub x y) (drop (apply-generic 'sub x y))) 

(define (mul x y) (drop (apply-generic 'mul x y))) 

(define (div x y) (drop (apply-generic 'div x y)))

; not all results of apply generic can be dropped. 
; If op is 'raise or 'project , result cannot be dropped otherwise we would not get the intended result
; also if the result of (apply proc (map contents args)) has no type tag, it cannot be dropped aswell
; So it is much better to add drop to operations like add, sub, mul, div that need simplifying
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (if (= (length args) 2)
              (let ((arg1 (car args))
                    (arg2 (cadr args)))
                (let ((type1 (type-tag arg1))
                      (type2 (type-tag arg2)))
                  (if (eq? type1 type2)
                      (error "No method for these types" (list op type-tags))  
                      (if (and (memq type1 tower)
                               (memq type2 tower))
                          (let ((pos1 (length (memq type1 tower)))
                                (pos2 (length (memq type2 tower))))
                            (if (> pos1 pos2)
                                (let ((transformed-arg1 ((repeated raise (- pos1 pos2)) arg1)))
                                  (apply-generic op transformed-arg1 arg2))
                                (let ((transformed-arg2 ((repeated raise (- pos2 pos1)) arg2)))
                                  (apply-generic op arg1 transformed-arg2))))
                          (error "one or more types not found in tower" type1 type2)))))
              (error "No method for these types --APPLY-GENERIC"
                     (list op type-tags)))))))

(define (raise x) 
  (if (eq? (type-tag x) (list-ref tower (- (length tower) 1)))
      (error "Object is already of highest type in hierarchy, cannot be raised further --RAISE" x)
      (apply-generic 'raise x)))

(define (project x) 
  (if (eq? (type-tag x) (car tower))
      (error "Object is already of lowest type in hierarchy, cannot be dropped further --PROJECT" x)
    (apply-generic 'project x)))

(define (equ? n1 n2)
  (if (eq? (type-tag n1) (type-tag n2))
      (apply-generic 'equ? n1 n2)
      #f))

(define (droppable? x)
  (if (eq? (type-tag x) (car tower))    ; object is of lowest hierarchy in tower             
      #f
      (equ? (raise (project x)) x)))

(define (drop x)
  (if (droppable? x)
      (drop (project x))
      x))       

(install-integer-package)
(install-rectangular-package)
(install-polar-package)
(install-rational-package)
(install-real-package)
(install-generic-complex-op-package)
(install-complex-package)
(define n (make-integer 5))
(define z1 (make-complex-from-real-imag 3 0))
(define z2 (make-complex-from-real-imag 3.5 0))
(define z3 (make-complex-from-real-imag 2 3))
(define n2 (make-rational 5 6))
(define z4 (make-complex-from-real-imag 3 n2))
; (raise n)
; (raise (raise n))
; (raise (raise (raise n)))
; (droppable? z)
; (project z)
; (droppable? (project z))
; (project (project z))
; (droppable? (project (project z)))
; (project (project (project z)))
; (drop z1)
; (drop z2)
; (drop z3)
; (mul z3 n)
; (add n z3)
; (drop n2)
; (add z3 z4)
(define z5 (make-complex-from-mag-ang (make-real 5.667) (make-rational 56 89)))
(define z6 (make-complex-from-real-imag (make-rational 3 5) (make-integer 7)))
(mul z5 z6)


  